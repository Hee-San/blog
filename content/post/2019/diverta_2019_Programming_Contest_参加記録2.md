---
title: "Diverta 2019 Programming Contest 参加記録 2"
date: 2019-05-13T21:17:06+09:00
archives: ["2019/05"]
tags: [競技プログラミング, AtCoder]
---

一昨日（2019/05/11）、AtCoderで開催された[diverta 2019 Programming Contest](https://atcoder.jp/contests/diverta2019)に参加しました。
C問題の復習記事です。
<!--more-->
---

## C - AB Substrings
> ##### 問題文
>
> すぬけ君は$N$個の文字列を持っています。
> $i$番目の文字列は$s_i$です。
>
> これらの文字列を好きな順序で並べたあと、連結して1つの文字列を作ることを考えます。
> 作った文字列に`AB`という部分文字列が含まれる個数としてありうる値のうち、最大値を求めてください。
>
> ##### 制約
> - $1 \leq N \leq 10^4$
> - $2 \leq |s_i| \leq 10$
> - $s_i$は英大文字のみからなる
> <cite>[C - AB Substrings](https://atcoder.jp/contests/diverta2019/tasks/diverta2019_c) </cite>

部分文字列が`AC`ではないのかと、3回確認しました。

さて、この問題で厄介な存在は、文字列のはじめにある`B`と、おわりにある`A`です。
途中にある`AB`は、連結後にも必ず残っています。
途中の`AB`は$n_0$個あったとします。

各文字列$s_i$を、次の4つに分類します。
ここで`X`は、`A`や`B`でない任意の文字です。

1. `B...A`
1. `B...X`
1. `X...A`
1. `X...X`

**パターンの有無で場合分けが必要**です。
自分はこの場合分け漏れで1WAしてしまいました。
上の各文字列パターンの個数を、それぞれ$n_1$~$n_4$としましょう。

</br>

まず、**すべてのパターンが十分にある場合**を考えてみます。
部分文字列の並べ方はさまざま考えられますが、ここではまず、このような並びから作るとしましょう。

- `X...A`, `B...A`, `B...A`, ... `B...A`, `B...X`

ここで`B...A`というパターンをすべて使い切ることにします。
`X...A`と`B...X`のパターンを、両端に1ずつ消費していることに注意です。
ここで作られる`AB`は、$n_1+1$個です。

次はこのような並びを作るとしましょう。

- `X...A`, `B...X`, `X...A`, `B...X`, ...

`X...A`と`B...X`のペアを作ります。
ここで`X...A`か`B...X`どちらか少なかったほうを使い切ります。
ここで作られる`AB`は、$min(n_2-1, n_3-1)$個です。

あとは余った文字列を並べるだけです。

よってこの場合で作られる`AB`は、$n_0 + n_1 + min(n_2, n_3)$個です。

</br>

**場合分けが必要なのは、$n1>0$かつ$n_2=n_3=0$のとき**です。
次の並びで、両端のどちらかが不在となります。

- `X...A`, `B...A`, `B...A`, ... `B...A`, `B...X`

この場合のみ、例外で、作られる`AB`は、$n_0 + n_1 -1$個です。

以上は[公式解説](https://img.atcoder.jp/diverta2019/editorial.pdf)と同じ方法です。

---

さて、以上で問題は解けました。
本番中はここまで整理することはなく、全パターンの有無の組み合わせで場合分けしていました。

問題を小さく分割することで、1つに取り組む間の考える事柄を減らすことができます。
初めに場合分けのif文だけ書いておくことで、漏れも防げるでしょう。
正確かつ速いコーディングを求められる場合は、それでよかったと思います。

しかし、今回このように改めて考察することで、新しい気付きもありました。
**予想に反し、場合分けは2つで良かった**のです。この点について、もう少し考察してみます。

さて、先の解法では、部分文字列を4パターンに分類していました。
しかし考察を行う中で、その場合分けも不要なことに気が付きました。
最終的な数式や場合分けの仕方は同じですが、少し違った視点から考えることができます。

注目するべきは、「部分文字列の終端にある`A`」の数と、「部分文字列の始端にある`B`」の数です。
それぞれ$m_A, m_B$としましょう。

これらを可能な限り使って`AB`をつくりたいと言うのがこの問題でした。
単純に考えて、その数は$min(m_A,m_B)$です。

ただし唯一、そうは作れない場合が存在します。
並べた文字列が、`B...A`, `B...A`, ... `B...A`という形になる場合。
両端に、`AB`に成れない`A`と`B`が残ってしまう場合です。
この場合は`AB`が1減ってしまいます。

実際のコードとしての実装は、先の解法と同じです。

---

このように、場合わけではなく、**例外処理**のような見方もできることに気が付きました。
こちらの解法のほうが直感的であるような気もします。
問題文を読んだときの気持ちをそのまま表現したような考え方です。

しかしまだ、どうも言葉として表現しきれていない気もします。
しばらくあとに読み返したときには、先の考察と違いがないように見えるかもしれません。
文章として書き残す能力も伸ばしていきたいものです。

今回の気付きが何かに直接生かされることは、ないかもしれません。
しかし、今回の問題考察もまた、自分の成長につながったような実感が得られました。
