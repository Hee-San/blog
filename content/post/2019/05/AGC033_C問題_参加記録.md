---
title: "AGC033 C問題 参加記録"
date: 2019-05-09T21:32:12+09:00
archives: ["2019/05"]
tags: [競技プログラミング, AtCoder]
---
2019/05/04に、AtCoderで開催された[AtCoder Grand Contest 033](https://atcoder.jp/contests/agc033)に参加しました。
C問題の復習記事です。
<!--more-->

- [AGC033 A問題](/blog/2019/agc033_a問題_参加記録/)
- [AGC033 B問題](/blog/2019/agc033_b問題_参加記録/)
- D問題以降、準備中

書いた記事を読み返していると、どうも、誰に向けて書いているのかわからないブログだなあと恥ずかしくなりました。
以前も、似た感情に陥り技術ブログを閉鎖したことが何度かありました。

しかし最近、解説を書きながら自分の理解が深まっているのをすごく感じます。
人から読まれる場所に置く文章としてはかなり恥ずかしいですが、書いているうちに文章力もつくと信じ、続けていこうと思います。

---

C問題は、WAのみ、ACできませんでした。
一番の敗因は焦りだったと思います。
実はこのとき駅前のミスドで参加していたのですが、通常24時までの営業のところ、GW中短縮営業で23時に閉店してしまうとのことで、バタバタしていました。

大まかな方針を店内でまとめ、その後の実装法などを歩きながら考え、帰宅後書いて提出しました。
最初の方針でのミスがWAにつながってしまったのですが、実装法はあっていたので、落ち着いていればACできていたかもなと思っています。。。

> ### C - Removing Coins
>
> ##### 問題文
> 高橋君と青木君は木を用いてゲームをすることにしました。
> ゲームに用いる木は$N$頂点からなり、各頂点には$1$から$N$の番号が割り振られています。
> また、$N-1$本の辺のうち、$i$本目の辺は頂点$a_i$と頂点$b_i$を結んでいます。
>
> ゲーム開始時、各頂点にはコインが一枚ずつ置いてあります。
> 高橋君と青木君は高橋君から始めて以下の操作を交互に行い、操作を行えなくなった方が負けになります。
>
> - コインが置いてある頂点を一つ選び、その頂点$v$に置いてあるコインをすべて取り除く。
> - その後、木上に残っているコインをすべて、今置いてある頂点に隣接する頂点のうち$v$に一番近い頂点に移動させる。
>
> つまり、木上にコインが残っていない状態で手番となった人の負けです。
> 二人が最適に行動したとき、どちらが勝つか求めてください。
>
> 先手の高橋君が勝つなら`First`を、後手の青木君が勝つなら`Second`を出力せよ。
>
> ##### 制約
> - $1 ≦ N ≦ 2 \times 10^5$
> - $1 ≦ a_i, b_i ≦ N$
> - $a_i \neq b_i$
> - 入力で与えられるグラフは木である。
>
> <cite>[C - Removing Coins](https://atcoder.jp/contests/agc033/tasks/agc033_c)</cite>

まずは、当日の自分が考えたWA解法について書いてゆきます。

### WAした解法
結論を先に書くと、[解説解答](https://img.atcoder.jp/agc033/editorial.pdf)の最後、3で割ったあまりを見る部分で、4で割ったあまりを見ていました。
これだけ見るとかなり惜しいところまでできているようですが、このミスの原因はかなり初歩のところです。

思考の過程を振り返ってみます。

さて、はじめに問題を見たとき、僕にはお手上げかなと考えていました。
というのも、近頃グラフ系の問題について実装力が無さすぎると思っており、これから勉強したいと予定を立てている最中だったからです。
また読んでいる途中は、コインの枚数を扱うのが大変そうだなと思いましたが、それは考えなくて良さそうなので安心しました。

ですので問題文を読んでも方針が思いつかず、サンプルケースを観察してみることにしました。
実際に木構造のグラフを紙に描き、コインの流れをイメージしてみると、1ターンずつにグラフの深さが1減ることに気が付きました。
ですので、初めにグラフの深さが偶数であれば`Second`、奇数であれば`First`なのかなと考えました。

しかしグラフの深さは、どのノードを根とするかによって変わってしまいます。
この解法は間違っていることに気が付きましたが、悪くない方向に進んでいるという予感はありました。

そして次に、グラフの直径が縮んでいく様子に気が付きました。
そして、直径にかかわらないような枝部分のノードは考える必要がないことにも気が付きました。

ここで、自分は偶然にも、グラフの`直径`という用語を知っていたために、この事実に気づくことができたように感じます。
もしもこの用語を知らなければ、解法を思いつくにも至らなかったでしょう。
用語を知ることで新しい視点が得られるので、勉強も大切だと思いました。

ここから自分は、**端のノードを値に取る場合**をまったく考えずに考察を進めました。
なぜ、4での剰余を考えるようになったのかははっきりと覚えていません。
しかしずっと、グラフの深さにとらわれていたような気がします。
そうして、歩きながらの思考は正解からずれて行き、WAに至りました。

### 正しい解法
[解説解答](https://img.atcoder.jp/agc033/editorial.pdf)で簡潔に書かれています。
直径に着目するところはあっていましたが、その後はまるで考えられていませんでした。

まず、**直径を1または2減らすことができる**ことに気づくべきでした。
直径で端となるノード、そのどれか1つのノードを選ぶことで、直径を1減らすことができます。
それ以外のノードを選べば、直径を2減らすことができます。

つぎに、**ある数字から2または1ずつ引く勝負は3の剰余で勝敗判定できる**ことに気づく必要がありました。
おそらく、自分が本番中にここまでたどり着いても、すぐに3剰余だとは気づかなかったでしょう。
しかしこの事実は有名なので、覚えていても損はないと思いました。

ここまでたどり着けば、あとはコーディングです。
直径を求める方法に手間取っていましたが、本番中に良い方法を見つけました。

1. 適当なノードを根とし、幅優先探索で、もっとも深いノードを1つ見つける。
1. 見つけたノードを根としたときの木の深さが、グラフの直径となる。

直径を知るためには、少なくとも1つの、直径の端となるノードがあれば、BFSで深さを測り直径が導けます。
一度適当な点でDFSを行うことで、直径の端となるノードを得ることができます。
エレガントさのある解法だと思いました。
一般に直径を求める方法として有名なようです。

またコンテスト直後、Twitter上に、直径を高速で求める方法の論文が上がっていました。

[An Exact Algorithm for Diameters of Large Real Directed Graphs](https://link.springer.com/chapter/10.1007%2F978-3-319-20086-6_5)

と思ったら、これは大規模なグラフで、しかも有向のものについてらしい（タイトル読んだだけ）。
大規模グラフについて直径を求めるのは、結構定番の問題らしく、論文もたくさん。
そういったアルゴリズム研究も面白そう。

まずはこれくらいの問題はすぐ解けるようになりたい。

---

以下、日記です。

時折、問題文のかなり長い問題があります。
前回のB問題などは、復習時に長いなと感じました。
しかし、本番ではあまり気にならないのです。
集中力からなのか、本質を理解したあとだから冗長に思えるのか。

どちらにせよ、復習時に書き写している現状、ムダが多いように感じています。
（載せるか載せないかは、載せたほうが圧倒的に自分の復習のためになると感じています。）
このあたりもスクレイピングで自動化したいなと考えています。

実は、4月の天下一コンテストの記事から、レートグラフのスクショ撮影を自動化しています。
バックグラウンドで見えないブラウザが開き、スクショを撮り、htmlタグからクロップ範囲を計算するようにしています。
これも記事化したいと思いつつ一ヶ月が過ぎようとしています。。。
