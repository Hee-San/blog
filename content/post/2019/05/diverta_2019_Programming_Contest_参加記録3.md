---
title: "Diverta 2019 Programming Contest 参加記録 3"
date: 2019-05-15T20:10:58+09:00
archives: ["2019/05"]
tags: [競技プログラミング, AtCoder]
---

先日（2019/05/11）、AtCoderで開催された[diverta 2019 Programming Contest](https://atcoder.jp/contests/diverta2019)に参加しました。
**E問題**の復習記事です。

<!--more-->

[前回の記事](https://hee-san.github.io/blog/2019/diverta_2019_programming_contest_%E5%8F%82%E5%8A%A0%E8%A8%98%E9%8C%B22/)ではC問題を考察したので、次はD問題、と思いきや、今日はE問題を考察します。

どうも今日は気分が落ち込みがちで。

気分を上げるために、かねてから勉強したいと思っていた**XOR**の問題をやってみようと思います！
スタアバックス珈琲を飲みながら。
写真は期間限定プリンアラモードフラペチーノです。

<img src="/blog/img/starbucks.jpeg" style="width:50%;">

元気だしていきましょう。

---
## E - XOR Partitioning
> ##### 問題文
>
> 長さ$n$の数列$a$の美しさを$a_1 \oplus a_2 \oplus \cdots \oplus a_n$で定義します。
> ここで$\oplus$はビットごとの排他的論理和を表します。
>
> 長さ$N$の数列$A$が与えられます。
> すぬけ君は$A$に$0$個以上の仕切りを入れて、いくつかの空でない連続する部分列に分割しようとしています。
>
> 仕切りを入れる方法は$2^{N-1}$通りあります。
> それらのうち、分割された数列たちの美しさが全て等しくなるものの個数を$10^9 + 7$で割ったあまりを求めてください。
>
> ##### 制約
> - 入力は全て整数
> - $1 \leq N \leq 5 \times 10^5$
> - $0 \leq A_i < 2^{20}$
> <cite>[E - XOR Partitioning](https://atcoder.jp/contests/diverta2019/tasks/diverta2019_e) </cite>

さて、ついにXORの問題です！
ブログを始めたときから、XOR問題については取り上げたいと思っていました。

まずはXORの性質からおさらいしましょう。

**XOR（排他的論理和）**とは、論理演算子の一種です。
その性質から、論理回路は別名**不一致回路**と呼ばれています。

$$0 \oplus 0 = 0$$
$$0 \oplus 1 = 1$$
$$1 \oplus 0 = 1$$
$$1 \oplus 1 = 0$$

記号としては、問題文にある$\oplus$の他に、$\underline{\vee}$なども用います。
私の経験では、前者は論理回路などで、後者は論理学などの講義で用いました。

さて、XORはANDやORに比べて、おもしろい使い方がたくさんできます。
その理由を一言で説明しましょう。
なんと**ビット列とXORは群を成す**んです！
しかも**アーベル群**！
ANDやORは群を成しませんので、これはかなり重要な事実です。
元気出てきました笑

---

それでは、ビット列とXORが群を成すのか見てみましょう。

#### 条件1. 演算は元に対し閉じているか。

1ビット${0,1}$に対するXORは、先で見たとおり、$0$または$1$になります。
これは、XORがブール演算子であることから自明です。
また、任意長のビット列に対しても、XORは各ビットで独立に働くため、XORでビット列長は変化しません。

以上のことから、**任意長のビット列について、XORは閉じた演算をする**ことが言えます。

このように、1ビットに対するブール演算の結果は、任意長のビット列に対しても、各ビットで独立に働きます。
よって以降の性質では、1ビットに対するXORの性質を調べるだけで十分です。

#### 条件2. 結合法則が成り立つか。

$$(0 \oplus 0) \oplus 0 = 0 \oplus (0 \oplus 0) = 0$$
$$(0 \oplus 0) \oplus 1 = 0 \oplus (0 \oplus 1) = 1$$
$$(0 \oplus 1) \oplus 0 = 0 \oplus (1 \oplus 0) = 1$$
$$(0 \oplus 1) \oplus 1 = 0 \oplus (1 \oplus 1) = 0$$
$$(1 \oplus 0) \oplus 0 = 1 \oplus (0 \oplus 0) = 1$$
$$(1 \oplus 0) \oplus 1 = 1 \oplus (0 \oplus 1) = 0$$
$$(1 \oplus 1) \oplus 0 = 1 \oplus (1 \oplus 0) = 0$$
$$(1 \oplus 1) \oplus 1 = 1 \oplus (1 \oplus 1) = 1$$

力技ですが、以上の結果から交換法則の成立が証明できました。

またこの結果を見ると、**XOR列の結果は、被演算子内の1の個数の偶奇**を示していることがわかります。
つまり、$A_0 \oplus A_1 \oplus ... \oplus A_N$の結果は、数列$A$内に$1$が偶数個だった場合**$0$**、奇数個だった場合**$1$**となります。

これは逆も成り立ちますし、ビット列については各桁で独立に計算されます。

#### 条件3. 単位元が存在するか。

はじめの4つ式のうち、以下の2つに注目してみましょう。

$$0 \oplus 0 = 0$$
$$1 \oplus 0 = 1$$

元${0,1}$に$0$を作用させても、値が変化していません。
ここから、**$0$は単位元**といえます。

#### 条件4. 逆元が存在するか。

群であるための、最後の条件です。

こんどは以下の2つに注目してみましょう。

$$0 \oplus 0 = 0$$
$$1 \oplus 1 = 0$$

ある元に、自身を作用させた場合、演算結果が単位元$0$となります。
つまり**逆元は自分自身**といえます！
$-0=0,-1=1$とも書けるでしょう。

**以上の条件1~4により、ビット列とXORは群を成すことが証明できました。**

さらに交換法則も証明できます。

#### 条件5. 交換法則が成り立つか。

1ビット${0,1}$に対するXORでは、先で見たとおり、$0\oplus1=1\oplus0=1$と交換法則が成立します。

**よって以上の条件1~5により、ビット列とXORはアーベル群（可換群）を成すことが証明できました。**

補足というか、メモと言うか。
記事書きながら、**乗法群andと加法群xorで環が成せそう**なことに気が付きました。
これを用いたAtCoder問題もありそう。
探して挑戦してみたいと思います。
ご存知の方は[Twitter](https://twitter.com/hee_san_)リプライ等で教えてください。。

---

さて、前置きが長くなってしまいました。
フラペチーノも残り2cm高という具合です。
本題の問題へと戻りましょう。

書きそびれていましたが、実は今回、本番中もいい線まで行っていました。
というのも、結果はテストケースも通せず未提出なのですが、[公式解説PDF](https://img.atcoder.jp/diverta2019/editorial.pdf)と方針は同じだったんです。

本番中の思考に沿って、振り返っていきたいと思います。

本番中も、まずはXORがアーベル群であることを思い出し、確認していました。
その中で**自分自身が逆元**という性質を確認したとき、次のことに気が付きました。

**2分割された数列たちの美しさがすべて等しくなるとき、全XOR和は$0$**

2つの部分数列の美しさを$b_0,b_1$とすると、$b_0=b_1$なので、$b_0 \oplus b_1=0$です。
また、分割後の数列の数が偶数となるときは常に、全XOR和が$0$だとも言えます。

さらに複数の部分数列に分割したとき、**偶数個目の数列の終わりまでの累積XORは$0$**になります。
部分数列の美しさを$b_0$~$b_N$とすると、以下の様に書けます。
$$b_0 \oplus b_1=0$$
$$b_0 \oplus b_1 \oplus b_2 \oplus b_3=0$$
$$b_0 \oplus b_1 \oplus ... \oplus b\_{2n+1}=0$$

こういうわけで、まず、**累積XORを取っておけば良い**ことに気づきました。
また、累積XORが$0$になるところがポイントだと気づきます。

偶数個で$0$となるということはわかりました。
では奇数個目はどうでしょう。
奇数個目は一定値にはならず、問題によってまちまちです。
ですが、1つの問題内では、**すべての奇数個目の累積XORは等しくなります**。
そしてこのときの累積XORは、部分数列の美しさに一致します。

**これで、この問題の性質は十分理解できたでしょう。**

---

これまでになく長い記事になっていそうです。
プラペチーノはもう無く、今はミスドのカフェオレが執筆のお供です。
ポンデリングが売り切れていたので、ダブルチョコレートを買いました。

**つぎは実装方法です。**
計算時間も気にしつつ、うまい方法を思いつく必要があります。
自分はDP等を考えたものの、答えにたどり着くことはできませんでした。

分割の個数の偶奇によって解き方が変わりそうです。
すべてのXOR和が$0$であるか否かでも問題が変わります。
DPで、分割の数ごとに見ていく気がしましたが、そうではなさそうです。
なぜなら、分割数$i$の問題を解くために、分割数$0$~$i-1$までの結果は役に立ちそうになかったからです。

それではおそらく、$A_0$~$A_i$を使って問題を解いてゆくパターンでしょう。
このとき、**DPの走査だけで$O(N)$**となります。
$N$の最大が$5\times10^5$と、ぎりぎりのラインです。
各問題を解くには、ほとんど時間がありません。

それでは、**各問題を$O(1)$で解く方法があるのでしょうか**。
それとも、**DPの大きさをもっと小さくできいるのでしょうか**。
本番中、自分はここまで想像できました。
しかしいい方法が思いつかなかったのです。

---

こうして思い返すと、いい考察ができていたように思います。
制約や計算量をしっかりと考えられています。
制約のこの数字は、ある意味ヒントだったと言えるでしょう。
ですのでここに気づけたのは良かったと思います。
ここでもうひと工夫必要なところが、やはり800点問題の難しさということでしょう。

さて、ここからは[公式解説](https://img.atcoder.jp/diverta2019/editorial.pdf)に沿って考えます。
ここでも累積XOR和を$b_i$としています。
$b_i=\oplus\_{j=0}^i A_j$です。

解説では、「$0,1,...,N+1$の番号がついた$N$個のマス」と書いていますが、これはおかしいです。
「$0,1,...,N-1$の番号がついた$N$個のマス」ということで議論を進めます。
解説内の$X$は、先の考察で考えた奇数個目の累積XORであり、部分数列の美しさでもあります。

**まずは、$b\_{N-1}\neq0$の場合を考えます。**

WIP
