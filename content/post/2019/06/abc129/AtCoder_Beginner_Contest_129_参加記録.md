---
title: "AtCoder Beginner Contest 129 参加記録"
date: 2019-06-09T23:16:17+09:00
archives: ["2019/06"]
tags: [競技プログラミング, AtCoder]
---

先日（2019/06/09）、AtCoderで開催された[AtCoder Beginner Contest 129](https://atcoder.jp/contests/abc129)に参加しました。

<!--more-->

![レートグラフ](https://hee-san.github.io/blog/post/2019/06/abc129/ratingGraph.png)

Rating+3です。
Eは解けておきたかった。。

今回の記事から、グラフ画像や問題引用を自動で生成するようにしてみました。
A,Bくらいは解説無しで良いと思いますが、せっかく生成されるので、自分のメモとして記録に価値があるのかどうか、一度書いて確かめてみたいと思います。

問題の種類で記事をタグ付けしたい。

---

> ## A - Airplane
> 配点 : 100 点
> Time Limit: 2 sec / Memory Limit: 1024 MB
>
> ### 問題文
>
> 空港 A, B, C があり、それぞれの空港の間では、双方向に飛行機が運航しています。
>
> 空港 A, B 間の飛行時間は片道 $P$ 時間、空港 B, C 間の飛行時間は片道 $Q$ 時間、空港 C, A 間の飛行時間は片道 $R$ 時間です。
>
> いずれかの空港からスタートして他の空港に飛行機で移動し、さらにそのどちらでもない空港に飛行機で移動するような経路を考えます。
>
> 飛行時間の和は最短で何時間になるでしょうか。
>
> ### 制約
>
> - $1 \leq P,Q,R \leq 100$
> - 入力は全て整数である
>
> <cite>[ABC129 A - Airplane](https://atcoder.jp/contests/abc129/tasks/abc129_a)</cite>

自分は``min({P+Q, Q+R, R+P})``で通しました。
解説では``P+Q+R - max({P, Q, R})``となっていました。

2つに要素を比較する際は、``min(A, B)``で良いのですが、3つ以上の場合``min({A, B, C})``とする必要があります。


**以下は余談です。**
この、``min({ })``や``max({ })``を用いた記法については、少し注意が必要です。

``{ }``はc++11から導入された、初期化子リストという機能です。
以下のように、配列やvectorなどのコンテナクラスに対して使うことが一番多いでしょう。

``` cpp
// 初期化
int a[] = {1, 2, 3};
vector<int> b = {1, 2, 3};
vector<vector<int> > c = {{1, 2, 3}, {4, 5, 6}};
```

ですが、以下のコードはコンパイルエラーとなってしまいます。
``` cpp
int a[] = {1, 2, 3};
int maxA = min(a); // コンパイルエラー

vector<int> b = {1, 2, 3};
int maxB = min(b); // コンパイルエラー
```
実のところ``{ }``は、それ単体で配列やvectorに変換されるわけではありません。
`initializer_list`というクラスです。
[(参照)](https://cpprefjp.github.io/reference/initializer_list/initializer_list.html)
`min`や`max`は、引数にこの`initializer_list`クラスを受け取ることはできますが、その他のコンテナクラスには対応していません。
使う場面は少ないですが、`minmax`も同様です。

また、その他のコンテナクラスから`initializer_list`クラスにキャストする手段も用意されていません。
（`initializer_list`クラスのiteratorはconst。`.push_back`なども不可。）
ですので、コンテナクラスの最小・最大要素を取るには、素直にforを書くか、`max_element`などを使ったほうが良いでしょう。
``` cpp
vector<int> v = {1, 2, 3};
int maxV = 0;
for(int a : v) maxV = max(maxV, a);
// もしくは
int maxV = *max_element(v.begin(), v.end()); // イテレータが帰ってくるので、*で値に変換
```
（`initializer_list`に対して`max_element`は使用可能です。`begin`,`end`,`size`などのメンバ関数は持っています。）

さらに余談。
上で`vector<int> b = {1, 2, 3};`というような記法を紹介しましたが、直接に`vector<int> b{1, 2, 3};`という形で初期化もできます。
集成体初期化（Aggregate Initilization）と言います。

そしてvectorには、要素数と値を指定して`vector<int> b(2, 3);`と初期化する方法もあります。
コンストラクタです。
これは`vector<int> b{3, 3};`に等しいわけです。

記法は似ていますが、まだややこしいというほどではありません。
しかしc++20にて、丸かっこによる集成体初期化が許可されるようなのです。
vectorで使えるようになるかはわかりませんが、次のようなコンテナを作れるようになるわけです。
``` cpp
T a{1, 2, 3}; // 集成体初期化。中身は{1, 2, 3}
T b(1, 2, 3); // 集成体初期化。中身は{1, 2, 3}
T c(2, 3); // コンストラクタ。中身は{3, 3}
```
これは非常にややこしい。
コンストラクタが優先されるようですが、この機能、追加しないほうが良いのでは...と思ってしまうような状況です。


A問題の解説からはずいぶん遠いところまで来てしまいましたが、競プロを期に、言語そのものへ興味をもつのもおもしろいと思います。
python提出によるTLEで苦しんでいる人が多いようですが、どんどんといろんな言語に挑戦してほしいものです。
3,4言語使い慣れると、それ以降、新規言語習得のコストはぐんと下がります。

さまざまなプログラミング言語の紹介記事も書いてみたいです。


---
> ## B - Balance
> 配点 : 200 点
> Time Limit: 2 sec / Memory Limit: 1024 MB
>
> ### 問題文
>
> $1$ から $N$ の番号がついた $N$ 個の重りがあり、番号 $i$ の重りの重さは $W\_i$ です。
>
> ある整数 $1 \leq T &lt; N$ に対してこれらの重りを、番号が $T$ 以下の重り と 番号が $T$ より大きい重りの $2$ グループに分けることを考え、それぞれのグループの重さの和を $S\_1, S\_2$ とします。
>
> このような分け方全てを考えた時、$S\_1$ と $S\_2$ の差の絶対値の最小値を求めてください。
>
> ### 制約
>
> - $2 \leq N \leq 100$
> - $1 \leq W\_i \leq 100$
> - 入力は全て整数である
>
> <cite>[ABC129 B - Balance](https://atcoder.jp/contests/abc129/tasks/abc129_b)</cite>

1列に並んだ重りの列に、仕切りを1箇所入れて、左右のグループに分けるイメージをしました。
仕切りを入れる方法は$N-1$通りあり、どこに入れるか全探索です。

それでは、$N-1$通りそれぞれで、$S\_1$と$S\_2$はどのように計算すると良いでしょうか。

まずは[公式解説](https://img.atcoder.jp/abc129/editorial.pdf)で言う"愚直な方法"から考えてみます。
この方法では、$N-1$通りそれぞれでfor文を回し、$S\_1$と$S\_2$を計算します。
2つのfor文は、合計で$N$個のループです。
これを$N-1$回試すので、計算量は$O(N^2)$です。
つまり、Nが2倍になれば計算時間はだいたい4倍、Nが100倍になれば計算時間はだいたい1万倍になるという意味です。
pythonなどのsum()を使ったとしても、内部では同じようなループが走るので、計算量は$O(N^2)$のままです。
今回の$N$は最大100と十分小さいので、$O(N^2)$でも実行回数はせいぜい$10^4$ほど、問題ありません。

計算量については、以下のような目安があります。

| 実行回数 | コンパイラ言語 (C++, java, C#, PyPy,...) | インタプリタ言語 (Python, Ruby,...) |
|:-----------:|------------:|:------------:|
| $10^5$ |  | 余裕を持って間に合う	 |
| $10^6$ | 余裕を持って間に合う	 | おそらく間に合う |
| $10^7$ | おそらく間に合う | ほぼ無理 |
| $10^8$ | ほぼ無理 |  |

これは1秒あたりの話ですが、2秒や5秒でも、桁が変わることはほぼありません。
また、定数倍の高速化もあまり意味がないと思っていいです。
（競技プログラミングに限った話です。)(PythonはC++に比べ2桁遅いとも言われます。）
競技プログラミングでは、「おそらく間に合う」は間に合わないと思っていていいでしょう。
「余裕を持って間に合う」ものが想定解であり、それより遅いアルゴリズムではTLEになるよう、テストケースが作られている場合が多いです。

次に[公式解説](https://img.atcoder.jp/abc129/editorial.pdf)にある$O(N)$の解を考えてみます。
この方法では、$N-1$通りそれぞれでfor文を回す必要はありません。

まず、あらかじめ、重さの総和を出しておきます。
これは$O(N)$です。
これがわかっていると、片方のグループの和だけ計算すれば、もう片方の和は$O(1)$で計算できます。

つぎに、仕切りを左から順に動かし、左側のグループの和を求めます。
つまり、0~i番目の重さの和を順に計算します。
このとき、毎回forループを回す必要はありません。
「0~i番目の重さの和」は「0~(i-1)番目の重さの和」に「i番目の重さ」を足すだけで良いので、前の結果を覚えておけば、$O(1)$でも止まります。

仕切りを動かす回数は$O(N)$なので、全体の計算量は$0(N)$となりました。


## **WIP**

これは累積和や動的計画法（DP）の基礎とも言えます。
---
> ## C - Typical Stairs
> 配点 : 300 点
> Time Limit: 2 sec / Memory Limit: 1024 MB
>
> ### 問題文
>
> $N$ 段の階段があります。高橋君は現在、上り口($0$ 段目)にいます。
> 高橋君は一歩で $1$ 段か $2$ 段上ることができます。
>
> ただし、$a\_1,a\_2,a\_3,....a\_M$ 段目の床は壊れており、その段に足を踏み入れることは危険です。
>
> 壊れている床を踏まないようにしながら、最上段($N$ 段目)にたどりつくまでの移動方法は何通りあるでしょうか？
> 総数を $1,000,000,007$ で割った余りを求めてください。
>
> ### 制約
>
> - $1 \leqq N \leqq 10^5$
> - $0 \leqq M \leqq N-1$
> - $1 \leqq a\_1 &lt; a\_2  &lt; $ $...$ $ &lt; a\_M \leqq N-1$
>
> <cite>[ABC129 C - Tests](https://atcoder.jp/contests/abc129/tasks/abc129_c)</cite>



---
> ## D - Lamp
> 配点 : 400 点
> Time Limit: 2 sec / Memory Limit: 1024 MB
>
> ### 問題文
>
> 縦 $H$ 行横 $W$ 列のグリッドが与えられます。このグリッドのうち、いくつかのマスには障害物が存在します。
>
> すぬけ君は、障害物のないマスのうち一つを選び、そのマスに明かりを設置しようとしています。
> 設置されたマスから、上下左右の四方向にまっすぐに光線が伸びます。それぞれの方向について、最初に障害物が存在するマスにぶつかる、もしくはグリッドの端にぶつかる手前のマスまで照らされます。明かりを設置したマスも照らされますが、障害物が存在するマスは照らされません。
>
> すぬけ君は明かりによって照らされるマスの個数を最大化したいです。
>
> $H$ 個の長さ $W$ の文字列 $S\_i$ ($1 ≤ i ≤ H$) が与えられます。$S\_i$ の $j$ 文字目 ($1 ≤ j ≤ W$) が `#` のとき、グリッドの上から $i$ 行目で左から $j$ 列目のマスには障害物があり、 `.` のときは障害物がありません。
>
> 照らされるマスの個数の最大値を求めてください。
>
> ### 制約
>
> - $1 ≤ H ≤ 2,000$
> - $1 ≤ W ≤ 2,000$
> - $S\_i$ は `#` と `.` のみからなる長さ $W$ の文字列
> - $S\_i$ ($1 ≤ i ≤ H$) のうちいずれかに `.` は最低 $1$ つ存在する
>
> <cite>[ABC129 D - Lamp](https://atcoder.jp/contests/abc129/tasks/abc129_d)</cite>

縦横の2方向で独立に解きましたが、計算量圧縮のためちょっと強引な方法に。
解説では4方向で独立に解いていました。
うまいと思います。

---
> ## E - Sum Equals Xor
> 配点 : 500 点
> Time Limit: 2 sec / Memory Limit: 1024 MB
>
> ### 問題文
>
> 正整数 $L$ が二進数表記で与えられます。
> 以下の条件を満たす非負整数 $a, b$ の組 $(a, b)$ がいくつ存在するか求めてください:
>
> - $a + b \leq L$
> - $a + b = a \mbox{ XOR } b$
>
> ただし、この値は非常に大きくなることがあるので、$10^9 + 7$ で割った余りを出力してください。
>
> 整数 $A, B$ のビットごとの排他的論理和 $a \mbox{ XOR } b$ は、以下のように定義されます。
>
> $a \mbox{ XOR } b$ を二進数表記した際の $2^k$ ($k \geq 0$) の位の数は、$A, B$ を二進数表記した際の $2^k$ の位の数のうち一方のみが $1$ であれば $1$、そうでなければ $0$ である。
> 例えば、$3 \mbox{ XOR } 5 = 6$ となります (二進数表記すると: $011 \mbox{ XOR } 101 = 110$)。
>
>
>
> ### 制約
>
> - $L$は二進数表記で与えられ、先頭文字は必ず $1$ である
> - $1 \leq L &lt; 2^{100,001}$
>
> <cite>[ABC129 E - Sum Equals Xor](https://atcoder.jp/contests/abc129/tasks/abc129_e)</cite>

桁DP、いままでやったことがなく苦戦しました。
解けるようになるまで、詳しく考えてみたいと思います。

---
> ## F - Takahashi's Basics in Education and Learning
> 配点: 600 点
> Time Limit: 3 sec / Memory Limit: 1024 MB
>
> ### 問題文
>
> <!-- 正の整数の組 $(L\_i, A\_i, B\_i, M\_i)$ が $Q$ 個与えられます．各組について，次の質問に答えてください．-->
> 長さ $L$ の等差数列 $s\_0, s\_1, s\_2, ... , s\_{L-1}$ があります。
>
> この等差数列の初項は $A$、公差は $B$ です。つまり、$s\_i = A + B \times i$ が成り立ちます。
>
> この数列の各項を、先頭に $0$ の無い十進法表記に直し、順につなげて読んでできる整数を考えます。たとえば、数列 $3, 7, 11, 15, 19$ をつなげて読んでできる整数は $37111519$ となります。この整数を $M$ で割ったあまりはいくらでしょうか。
>
> ### 制約
>
>
> - 入力はすべて整数である
> - $1 \leq L, A, B &lt; 10^{18}$
> - $2 \leq M \leq 10^9$
> - 等差数列の要素は全て $10^{18}$ 未満
>
> <cite>[ABC129 F - Takahashi's Basics in Education and Learning](https://atcoder.jp/contests/abc129/tasks/abc129_f)</cite>

いままで600点以上の問題は、解説を見たこともほとんどありません。
いつもは飛ばしていましたが、せっかく問題文が記事に自動生成されたので、考察してみましょう。

行列積を使うようです。
数学でなくプログラミングで行列積、フィボナッチ数列の計算くらいにしか使った記憶がありません。

---
